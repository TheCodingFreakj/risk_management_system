<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Data Handler</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            width: 100%;
        }

        h1,
        h2 {
            text-align: center;
            color: #333;
        }

         /* Style the grid container */
         .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Two equal-width columns */
            grid-gap: 20px; /* Spacing between grid items */
            margin: 20px 0; /* Margin above and below the grid */
        }

        /* Style the individual grid items */
        .grid-item {
            padding: 10px;
            border: 1px solid #ccc; /* Border around each grid item */
            border-radius: 5px; /* Rounded corners */
            background-color: #f9f9f9; /* Background color for grid items */
        }

        .grid-item h2 {
            margin-top: 0; /* Remove top margin for h2 in grid items */
        }

        #container {
            display: flex;
            flex-direction: column;
        }

        .flex_container {
            display: flex;
            padding: 2%;
        }

        #chart1,
        #chart2,
        #chart3,
        #chart4 {
            padding: 10px;
        }

        #cont {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        div#graphs-container {
    padding: 40px;
}
        .stock-data {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px;
            padding: 20px;
            background: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .stock-data p {
            margin: 5px 0;
        }

        .stock-data p span {
            font-weight: bold;
            color: #000;
        }

        button {
            padding: 10px 20px;
            width: 200px;
            height: 60px;
            margin: 0px 9px;
            color: #fff;
            background: black;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        select#scenario-select {
            width: 200px;
            height: 60px;
        }

        button:hover {
            background-color: #0056b3;
        }

        #chart-container {
            padding: 1.6%;
        }

        #graphs {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        
        h2,
        h3 {
            margin-top: 0;
        }

        .loading {
            font-size: 24px;
            font-weight: bold;
            color: #888;
            margin-top: 50px;
        }
        .flex-container-3 {
    display: flex;
    justify-content: space-around;
}
.loader-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
    border-left-color: #000;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
    </style>
</head>
<!-- onload="initializePage()" -->

<body onload="initializePage()">

   <div id="main_div">
    <div id="loader" class="loader-container">
        <div class="spinner"></div>
    </div>
    
    <div id="container">
        <h1>Market Data Handler</h1>
        
        <div class="flex_container">
            <button onclick="connectWebSocket()">Connect WebSocket</button>


            <select id="scenario-select">
                <option value="" disabled selected>Select a scenario</option>
                {% for scenario in scenarios %}
                <option value="{{ scenario.id }}" data-description="{{ scenario.description }}"
                    data-impact="{{ scenario.impact_factor }}">
                    {{ scenario.name }}
                </option>
                {% endfor %}
            </select>

            <div id="scenario-details" style="width: 700px; margin: 0 40px;">
                <p id="description"></p>
                <p><strong>Impact Factor:</strong> <span id="impact-factor"></span></p>
            </div>
        </div>

        <!-- <div id="loader" class="loader-container" style="display: none;"></div> -->
        <div id="socket-status" style="font-weight: bold;color: rgb(33, 23, 23);position: relative;left: 3%;">Disconnected</div>
        <div id="cont">
            <div id="chart1"></div>
            <div id="chart2"></div>
            <div id="chart3"></div>
            <div id="chart4"></div>
        </div>

        <div class="stock-data">
            <h3>Stock Data for <span id="latestDate"></span> <span id="symbol"></span></h3>
            <p>Current Price: <span id="close"></span></p>
            <p>Day High: <span id="high"></span></p>
            <p>Day Low: <span id="low"></span></p>
            <p>Open: <span id="open"></span></p>
            <p>Previous Close: <span id="previousClose"></span></p>
            <p>Volume: <span id="volume"></span></p>
            <p>MarketCap: <span id="marketCap"></span></p>
            <p>DividendYield: <span id="dividendYield"></span></p>
            <p>TrailingPE: <span id="trailingPE"></span></p>
            <p>TrailingEps: <span id="trailingEps"></span></p>
            <button>Signal: <span id="signalValue"></span></button>
        </div>

        <div id="chart-container">
            
        </div>
    </div>

    <div id="graphs-container">
            <!-- Loader container -->
    
     
    </div>

       
   
    
    <div id="content-container" style="display: none;">
        <!-- This is where the final content will be loaded -->
    </div>

    <div id="container">
        <div id="graphs-container">
                <!-- Loader container -->
  

        </div>
    </div>
    </div>


    <script>
document.addEventListener("DOMContentLoaded", function() {
            // Show the loader
            const loader = document.getElementById("loader");
            const contentContainer = document.getElementById("content-container");

            // Fetch the final context
            fetch("/get-final-context/")  // Adjust the URL according to your routing
                .then(response => response.json())
                .then(data => {
                    // Hide the loader
                    loader.style.display = "none";

                    // Show the content container
                    contentContainer.style.display = "block";

                    console.log(data.html_entries);

                    // Insert the HTML content first
                    if (data.html_entries) {
                        data.html_entries.forEach((htmlEntry, index) => {
                            // Inject the HTML for each plot
                            contentContainer.innerHTML += htmlEntry;
                        });

                        // Render the corresponding Plotly plots after the HTML has been injected
                        Object.keys(data.graphs).forEach((plotDivId) => {
                            const graphData = data.graphs[plotDivId];
                            Plotly.newPlot(plotDivId, graphData.data, graphData.layout);
                        });
                    } else {
                        contentContainer.innerHTML = "<p>No data available.</p>";
                    }
                })
                .catch(error => {
                    console.error("Error fetching final context:", error);
                    loader.innerHTML = "<p>Failed to load data. Please try again later.</p>";
                });
        });

                // JavaScript to handle loader visibility
                document.addEventListener("DOMContentLoaded", function() {
            const loader = document.getElementById('loader');

            // Check if any of the inner divs have content and hide the loader
            function checkContentAndHideLoader() {
                const innerDivs = document.querySelectorAll('#chart1, #chart2, #chart3, #chart4, #graphs-container');
                let contentLoaded = false;

                innerDivs.forEach(div => {
                    if (div.innerHTML.trim() !== "") {
                        contentLoaded = true;
                    }
                });

                if (contentLoaded) {
                    loader.style.display = 'none';
                }
            }

            // Initial check
            checkContentAndHideLoader();

            // Periodically check every second
            setInterval(checkContentAndHideLoader, 1000);
        });
        // Function to show the loader
        function showLoader() {
            document.getElementById('loader').style.display = 'flex';
        }

        // Function to hide the loader
        function hideLoader() {
            document.getElementById('loader').style.display = 'none';
        }
        async function fetchAndUpdateData() {
            try {
                const response = await fetch("/load-additional-data/");
                if (!response.ok) {
                    throw new Error('Failed to load additional data');
                }
                const data = await response.json();
                console.log("..............................")
                // Inject the graphs and html_output content
                const dynamicContent = document.getElementById("graphs-container");

                
                if (data.graphs) {
                    for (const [ticker, graphData] of Object.entries(data.graphs)) {
                        const graphContainer = document.createElement('div');
                        graphContainer.classList.add('graph-container');
                        graphContainer.innerHTML = `
                        <h2>${ticker} - Your Risk Management</h2>
                        ${graphData.var_value !== undefined ? `
                            <div class="graph-container">
                                <h3 style="font-weight: bold;">Value-at-Risk (VaR)</h3>
                                <p style="font-weight: bold;">VaR Value: ${graphData.var_value}, Confidence Level: ${graphData.confidence_level}</p>
                                <p>This means that there is a ${graphData.confidence_level}% chance that the portfolio will not lose more
                                    than ${graphData.percentage}% of its value in a day.</p>
                                <p>The potential for daily losses up to nearly ${graphData.percentage}% at a ${graphData.confidence_level}%
                                    confidence level suggests that the current portfolio could experience further negative returns</p>
                                <p style="font-weight: bold;">Probable Decision:</p>
                                <p style="font-weight: bold;">${graphData.decision}</p>
                            </div>` : ''
                            }
                        <div class="flex-container-3"> 
                        ${graphData.daily_returns_div ? `<div class="graph-container2"><h3>Daily Returns</h3>${graphData.daily_returns_div}</div>` : ''}
                        ${graphData.portfolio_returns_div ? `<div class="graph-container2"><h3>Portfolio Returns</h3>${graphData.portfolio_returns_div}</div>` : ''}
                        </div>
                    `;
                        dynamicContent.appendChild(graphContainer);

                        // Execute any inline scripts found in the graph data
                        executeScripts(graphContainer);
                    }
                }

                lastFetchFailed = false; // Mark the last fetch as successful
            } catch (error) {
                console.error('Error during incremental loading:', error);
                document.getElementById("loading-message").innerText = "Failed to load data. Please try again later.";
                lastFetchFailed = true; // Mark the last fetch as failed
            } finally {
                isFetching = false; // Reset the flag once the fetch is complete
            }
        }

        // Function to execute scripts within dynamically inserted HTML
        function executeScripts(container) {
            const scripts = container.getElementsByTagName('script');
            for (const script of scripts) {
                const newScript = document.createElement('script');
                if (script.src) {
                    newScript.src = script.src;
                } else {
                    newScript.textContent = script.textContent;
                }
                document.head.appendChild(newScript).parentNode.removeChild(newScript);
            }
        }
        async function initializePage() {
            document.getElementById('scenario-select').addEventListener('change', handleScenarioChange);
            await connectWebSocket();
            await fetchAndUpdateData();
           
        }

        function handleScenarioChange() {
            const selectedOption = this.options[this.selectedIndex];
            const description = selectedOption.getAttribute('data-description');
            const impactFactor = selectedOption.getAttribute('data-impact');

            document.getElementById('description').innerText = description;
            document.getElementById('impact-factor').innerText = impactFactor;

            fetchScenarioData(this.value);
        }

        async function fetchScenarioData(scenarioId) {
            try {
                const response = await fetch(`/get-scenario-data/${scenarioId}/`);
                const data = await response.json();
                if (response.ok) {
                    renderCharts(data);
                } else {

                    console.error('Error fetching scenario data:', response.statusText);
                }
            } catch (error) {
                console.error('Error fetching scenario data:', error);
            }
        }

        function renderCharts(data) {
            Plotly.newPlot('chart1', JSON.parse(data.chart1).data, JSON.parse(data.chart1).layout);
            Plotly.newPlot('chart2', JSON.parse(data.chart2).data, JSON.parse(data.chart2).layout);
            Plotly.newPlot('chart3', JSON.parse(data.chart3).data, JSON.parse(data.chart3).layout);
            Plotly.newPlot('chart4', JSON.parse(data.chart4).data, JSON.parse(data.chart4).layout);
        }

        function connectWebSocket() {
            const socketStatus = document.getElementById('socket-status');
            socketStatus.innerText = 'Connecting...'; // Indicate that the WebSocket is connecting
            socketStatus.style.color = 'orange';

            const socket = new WebSocket('ws://' + window.location.host + '/ws/quotes/');

            socket.onmessage = async function (e) {
                const data = JSON.parse(e.data);
                updateStockData(data.quote);
                await fetchChartData(data.quote.symbol);
            };

            socket.onclose = function (e) {
                console.error('WebSocket closed unexpectedly');
                socketStatus.innerText = 'Disconnected';
                socketStatus.style.color = 'red';
            };

            socket.onopen = function (e) {
                console.log('WebSocket connection opened');
                socketStatus.innerText = 'Connected';
                socketStatus.style.color = 'green';
            };

            socket.onerror = function (e) {
                console.error('WebSocket error:', e);
                socketStatus.innerText = 'Error';
                socketStatus.style.color = 'red';
            };
        }


        function updateStockData(quote) {
            document.getElementById('signalValue').innerText = quote.signal || '-';
            document.getElementById('symbol').innerText = quote.symbol || '-';
            document.getElementById('close').innerText = quote.data.currentPrice || '-';
            document.getElementById('high').innerText = quote.data.dayHigh || '-';
            document.getElementById('low').innerText = quote.data.dayLow || '-';
            document.getElementById('open').innerText = quote.data.open || '-';
            document.getElementById('previousClose').innerText = quote.data.previousClose || '-';
            document.getElementById('volume').innerText = quote.data.volume || '-';
            document.getElementById('marketCap').innerText = quote.data.marketCap || '-';
            document.getElementById('dividendYield').innerText = quote.data.dividendYield || '-';
            document.getElementById('trailingPE').innerText = quote.data.trailingPE || '-';
            document.getElementById('trailingEps').innerText = quote.data.trailingEps || '-';
            document.getElementById('latestDate').innerText = quote.data.latestDate || '-';
        }

        async function fetchChartData(symbolUpper) {
            try {
                const response = await fetch('/chart-data/');
                const data = await response.json();

                if (response.ok) {
                    for (const [symbol, chartHtml] of Object.entries(data)) {
                        if (symbolUpper === symbol) {
                            showChart(chartHtml);
                            break;
                        }
                    }
                } else {
                    console.error('Error fetching chart data:', response.statusText);
                }
            } catch (error) {
                console.error('Error fetching chart data:', error);
            }
        }

        function showChart(chartHtml) {
            const container = document.getElementById('chart-container');
            container.innerHTML = chartHtml;

            const scripts = container.getElementsByTagName('script');
            for (const script of scripts) {
                const newScript = document.createElement('script');
                if (script.src) {
                    newScript.src = script.src;
                } else {
                    newScript.textContent = script.textContent;
                }
                document.head.appendChild(newScript).parentNode.removeChild(newScript);
            }
        }

       
    </script>
</body>

</html>